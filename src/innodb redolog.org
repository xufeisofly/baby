#+TITLE: InnoDB 笔记
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>

** redo log

   与 binlog, error log 等 mysql server 层提供的日志不同，redo log 是 innodb 存储引擎提供的日志文件，是 innodb 特有的，它记录了对 innodb 的事务日志。通常对于 mysql 的 DML 操作会先通过 innodb change buffer，然后在 doublewrite 到磁盘中，在落盘期间一旦异常宕机，就会造成数据错误，所以 innodb 提供了 WAL 技术，即 Write-Ahead logging，再每次变更数据时，都先写 redo 日志，这样一旦宕机，也可以从 redo log 中恢复数据。

   在这里会产生疑问。

   #+BEGIN_QUOTE
   如果在记录 redo log 过程中异常故障怎么办？本质上和更新数据文件不是一样的吗？
   #+END_QUOTE
   
   要解释这个问题，需要明确以下几点。

*** redo log buffer, os buffer
	
	redo log file 的写入和 ibd 等文件一样，也要经过 buffer，毕竟如果一次 DML 就 fsync 一条 write-log 会导致大量磁盘 IO，影响性能。更具体来说，redo log 要经过两层 buffer，分别是 innodb 提供的 redo log buffer 和 操作系统提供的 os buffer。经过一层 os buffer 的好处是即使 mysql 挂掉，只要服务器没有宕机则数据就不会丢失。所以一次 commit 的过程如下。

	#+CAPTION: redo.png
	[[file:/Users/norris/projects/baby/src/../images/redo.png.png]]	

	那么 buffer 什么时候 flush 呢？

*** ~innodb_flush_log_at_trx_commit~ 参数

	innodb 如何在 commit 的时候将 log buffer 刷新到 log file，可以通过 ~innodb_flush_log_at_trx_commit~ 来配置

	- 变量为 0: 事务提交不会更新 os buffer，会通过 master thread 每秒的任务来 flush redo buffer 到 os buffer，紧接着 fsync 到 log file，因此若系统崩溃，会丢失 1s 数据
    - 变量为 1: 事务提交即会 flush 并 fsync 到 log file，不会丢失数据，但影响磁盘 IO 性能
	- 变量为 2: 事务提交会 flush 到 os buffer，但通过 master thread 每秒 fsync 到磁盘 log file，所以 mysql 崩溃但服务器不宕机，就不会丢失数据，若服务器宕机，则会丢失 1s 数据。同时不影响磁盘性能

#+CAPTION: flush
[[file:/Users/norris/projects/baby/src/../images/flush.png.png]]

** InnoDB 逻辑存储结构

   innoDB 存储结构分为

   - 表空间(tablespace)
   - 段(segment)
   - 区(extent)
   - 页(page)

   如下图

   #+CAPTION: innodb 逻辑存储结构
   #+ATTR_HTML: :onerror this.src='https://i.loli.net/2020/01/05/hwfBTnus9W6GjX1.png'
[[file:/Users/norris/projects/baby/src/../images/innodb_storage_s.png]]

*** 表空间

	表空间是存储结构的最上层，存在一个共享表空间 ibddata1，除此之外若启用 ~innodb_file_per_table~ 参数，则每一个表都有自己的 ibd 表空间文件。打开 mysql 根目录就可以看到

	#+CAPTION: 表空间文件
	#+ATTR_HTML: :onerror this.src='https://i.loli.net/2020/01/05/hlzo54WEfDNG87d.png'
	[[file:/Users/norris/projects/baby/src/../images/my_ibd.png]]
	
	自己的表空间中存放以下信息

	- 数据、索引、插入缓冲 bitmap 页

	共享表空间存放以下信息
	
	- 回滚信息、插入缓冲页、系统事务信息、二次写缓冲（即系统类和缓冲类信息）

	如
	
	#+CAPTION: ibd 内容
	#+ATTR_HTML: :onerror this.src='https://i.loli.net/2020/01/05/BEDqVUPe1a42h7m.png'
[[file:/Users/norris/projects/baby/src/../images/my_idb_content.png]]


*** 段
	
*** 区

	页的大小可以配置，区中可以有很多页，但是，*区的大小永远是 1M*，一般的一个页是 16KB，也就是说一个区有64个连续的页

	但是刚创建表的时候，每个段会先用32个碎片页来存放数据，所以不会去申请区，即在数据量超过32个碎片页之前，段中是没有区的，但一旦有了区，这个区大小肯定是 1M

	
*** 页

	页是 ~innodb~ 管理磁盘的最小单位，一般有如下类型

	- 数据页(B-tree node)
    - undo 页(undo log page)
	- 系统页(system page)
	- 事务数据页(transaction system page)
	- 插入缓冲位图页(insert buffer bitmap)
	- 插入缓冲空闲列表页(insert buffer free list)
    - 未压缩的二进制大对象页(uncompressed blob page)
	- 压缩的二进制大对象页(compressed blob page)


#+CAPTION: 999
#+ATTR_HTML: :onerror this.src='https://i.loli.net/2020/01/06/OdBuP8oQgFTe9WA.png'
[[file:/Users/norris/projects/baby/src/../images/999.png]]
