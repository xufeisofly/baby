#+TITLE: SICP exercises
#+Html_head: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>

** Exercise 1.1
   
   10
   12
   8
   3
   4
   a
   b
   19
   #f
   4
   16
   6
   6
   16

** Exercise 1.2

   #+begin_src scheme
     (/ (+ 
         5 4 
         (- 2 
            (- 3 
               (+ 6 
                  (/ 4 5))))) 
        (* 3 
           (- 6 2) 
           (- 2 7)))
   #+end_src

** Exercise 1.3

   #+begin_src scheme
     (define (sum_of_square x y) 
       (+ (* x x) (* y y)))

     (define (procedure a b c) 
       (cond ((or (< c a) (< c b)) (sum_of_square a b))
             ((or (< b a) (< b c)) (sum_of_square a c))
             ((or (< a b) (< a c)) (sum_of_square b c))))
   #+end_src

** Exercise 1.4

   if b > 0ï¼Œreturn a + b, else return a - b, overall return a + abs(b)

** Exercise 1.5

   normal order:
   
   #+begin_src scheme
     (test x y)
     (if (= x 0) 0 y)
     (if (= 0 0) 0 (p))
     0
   #+end_src

   applicative order:
   
   #+begin_src scheme
     (test 0 (p))
     (test 0 (p))
     ...
   #+end_src

** Exercise 1.6

   use if:
   
   special form will not use applicative order to analize a procedure, thus clause in old if will not run unless predicate meets. 

   use new-if:
   
   use applicative order, sqrt-iter clause will be expanded, leading maximum recursion depth exceeded.

** Exercise 1.7

   because (good-enough?) is checked by absolute difference, small number might meet that in the very beginning.

   for large numbers, is might cause (improve guess x) equals (guess), thus trapping in infinite loop.

     #+begin_src scheme
     (define (abs x)
       (if (< x 0)
           (* -1 x)
           x))

     (define (square x)
       (* x x))

     (define (sqrt-iter guess old-guess x)
       (if (good-enough? guess old-guess x)
           guess
           (sqrt-iter (improve guess x) guess x)))

     (define (improve guess x)
       (average guess (/ x guess)))

     (define (average x y)
       (/ (+ x y) 2))

     (define (good-enough? guess old-guess x)
       (< (abs (- guess old-guess)) (* guess 0.001)))

     (define (sqrt x)
       (sqrt-iter 1.0 2.0 x))

     (define (new-if predicate then-clause else-clause)
       (if (predicate)
           then-clause
           else-clause))
     #+end_src

** Exercise 1.8

   #+begin_src scheme
     (define (cube-root x)
       (cube-root-iter 1.0 2.0 x))

     (define (cube-root-iter guess old-guess x)
       (if (good-enough? guess old-guess x)
           guess
           (cube-root-iter (improve guess x) guess x)))

     (define (improve guess x)
       (/ (+ (/ x
                (* guess guess))
             (* 2 guess))
          3))

     (define (good-enough? guess old-guess x)
       (< (abs (- guess
                  old-guess))
          (* guess 0.001)))

     (define (abs x)
       (if (< x 0)
           (* -1 x)
           x))

     (cube-root 27)

   #+end_src

** Exercise 1.9

   first is recursive, second is iterative.

** Exercise 1.10

   #+begin_src scheme
     (A 1 10)
     (A (- 1 1) (A 1 (- 10 1)))
     (A 0 (A (- 1 1) (A 1 8)))
     (A 0 (A 0 (A 1 8)))
     (A 0 (A 0 (A 0 (A 1 7))))
     (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
     ...
     1024

     (A 2 4)
     (A 1 (A 2 3))
     (A 1 (A 1 (A 2 2)))
     (A 1 (A 1 (A 1 (A 2 1))))
     (A 1 (A 1 (A 1 2)))
     (A 1 (A 1 (A 0 (A 1 1))))
     (A 1 (A 1 (A 0 2)))
     (A 1 (A 1 4))
     (A 1 (A 0 (A 1 3)))
     (A 1 (A 0 (A 0 (A 1 2))))
     (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
     (A 1 (A 0 (A 0 (A 0 2))))
     (A 1 (A 0 (A 0 4)))
     (A 1 16)

     65536

     (A 3 3)
     (A 2 (A 3 2))
     ...
     (A 2 4)
     65536
   #+end_src

** Exercise 1.11

   recursive process

   #+begin_src scheme
     (define (f n)
       (if (< n 3)
           n
           (+ (f (- n 1))
              (* 2 (f (- n 2)))
              (* 3 (f (- n 3))))))
   #+end_src

   iterative process

   #+begin_src scheme
     (define (f n)
       (f-iter 2 1 0 n))

     (define (f-iter a b c count)
       (if (< count 3)
           a
           (f-iter (+ a
                      (* 2 b)
                      (* 3 c))
                   a
                   b
                   (- count 1))))
   #+end_src

** Exercise 1.12

   #+begin_src scheme
     (define (f r c)
       (if (and (> r 1)
                (not (eq? r c))
                (not (eq? c 0)))
           (+ (f (- r 1) (- c 1))
              (f (- r 1) c))
           1))
   #+end_src
